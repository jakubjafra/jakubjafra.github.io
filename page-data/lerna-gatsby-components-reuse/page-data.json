{"componentChunkName":"component---node-modules-gatsby-theme-blog-core-src-templates-post-query-js","path":"/lerna-gatsby-components-reuse/","result":{"data":{"site":{"siteMetadata":{"title":"Devlog","social":[{"name":"email","url":"mailto:jakub.jafra@gmail.com"},{"name":"linkedin","url":"https://www.linkedin.com/in/jakub-jafra-355150a4/"},{"name":"github","url":"https://github.com/jakubjafra"}]}},"blogPost":{"__typename":"MdxBlogPost","id":"fed733e3-160f-56fc-8259-610061f37fdc","excerpt":"In my latest project, I'm using monorepo structure using lerna. I'm sharing some common components\nbetween two different frontend projects…","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Reusing custom Material UI components using Lerna and Gatsby\",\n  \"date\": \"2021-02-15T00:00:00.000Z\",\n  \"tags\": [\"gatsby\", \"material-ui\", \"lerna\", \"monorepo\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"In my latest project, I\\u2019m using monorepo structure using lerna. I\\u2019m sharing some common components\\nbetween two different frontend projects. One of them is a Gatsby project that is causing the\\nproblem. The project\\u2019s structure looks like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \".\\n\\u251C\\u2500\\u2500 packages\\n\\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 admin # CRA based project\\n\\u2502   \\u2502   \\u2514\\u2500\\u2500 package.json\\n\\u2502\\xA0\\xA0 \\u251C\\u2500\\u2500 frontend # Gatsby based project\\n\\u2502   \\u2502   \\u2514\\u2500\\u2500 package.json\\n\\u2502\\xA0\\xA0 \\u2514\\u2500\\u2500 ui # common UI elements\\n|       \\u2514\\u2500\\u2500 package.json\\n\\u251C\\u2500\\u2500 lerna.json\\n\\u2514\\u2500\\u2500 package.json\\n\")), mdx(\"p\", null, \"At a root level, I\\u2019m installing common dependencies for the project. Those are packages like\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"react\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"react-dom\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"@material-ui/core\"), \". It\\u2019s a common practice for lerna projects: you only\\nneed to install those once, saving your time while reinstalling dependencies.\"), mdx(\"h2\", {\n    \"id\": \"the-problem\"\n  }, \"The problem\"), mdx(\"p\", null, \"My \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"frontend\"), \" package is the one using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gatsby\"), \" and local \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ui\"), \" package. When trying to run the\\nproject via \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gatsby develop\"), \" while importing some components from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ui\"), \" I got a blank gatsby page and\\nerrors like these in the console:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"Uncaught Error: Unable to find node on an unmounted component.\\n// or:\\nUncaught Error: Invariant Violation\\n\")), mdx(\"p\", null, \"I\\u2019ve found out that despite not having \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"react\"), \" in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"frontend\"), \"\\u2019s package.json it was found in\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"packages/frontend/node_modules\"), \"! Based on \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"package-lock.json\"), \", it turned out it was required by\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gatsby\"), \". The errors I got were caused by two different React instances being present on a live\\nsite: one from Gatsby, and the other one from my ui components. I needed to find a way to have only\\none \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"react\"), \" in my project - despite Gatsby\\u2019s\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby/package.json\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"peerDependencies\"), \" requirements\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"\\\"peerDependencies\\\": {\\n  \\\"react\\\": \\\"^16.4.2 || ^17.0.0\\\",\\n  \\\"react-dom\\\": \\\"^16.4.2 || ^17.0.0\\\"\\n},\\n\")), mdx(\"h2\", {\n    \"id\": \"the-solution\"\n  }, \"The solution\"), mdx(\"p\", null, \"I didn\\u2019t exactly found a solution not to install React with Gatsby. I did, however, found a good\\nenough workaround.\"), mdx(\"p\", null, \"It turns out that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"npm\"), \" follows symlinks while resolving dependencies. There is a small utility\\npackage called \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.npmjs.com/package/npm-link-shared\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"npm-link-shared\")), \" that does exactly\\nthat. I could overwrite the forcefully-installed React with this command:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"npm-link-shared ../../node_modules . react react-dom\\n\")), mdx(\"p\", null, \"This solution worked, but could be improved. In \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"frontend/package.json\"), \" I\\u2019ve added this code:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"\\\"scripts\\\": {\\n  \\\"preinstall\\\": \\\"rm -rf ./node_modules\\\",\\n  \\\"postinstall\\\": \\\"npm-link-shared ../../node_modules . react react-dom\\\"\\n}\\n\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"postinstall\"), \" script ensures that dependencies will be linked after each \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"npm install\"), \" call.\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"preinstall\"), \" script ensures a clean installation. I was getting some errors related to a\\npresence of symlinks that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"npm\"), \" was not expecting.\"), mdx(\"p\", null, \"This solution was tested on \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"npm@6\"), \" and is in use in production. It wouldn\\u2019t work with\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"react-native\"), \" thought, as it doesn\\u2019t follow symlinks when building the application.\"));\n}\n;\nMDXContent.isMDXComponent = true;","slug":"/lerna-gatsby-components-reuse/","title":"Reusing custom Material UI components using Lerna and Gatsby","tags":["gatsby","material-ui","lerna","monorepo"],"date":"February 15, 2021","image":null,"imageAlt":null,"imageCaptionText":null,"imageCaptionLink":null,"socialImage":null},"previous":{"__typename":"MdxBlogPost","id":"90047d6c-9f9b-5943-b5ca-cba285ebec0e","excerpt":"While creating this very blog I've encountered a weird error where gatsby is not building images in\nproduction. This issue was not…","slug":"/gatsby-images-not-built/","title":"Gatsby images not built, based on the presence of \".cache\" or \"public\" folders","date":"October 27, 2020"},"next":{"__typename":"MdxBlogPost","id":"56b1d61b-c6f9-5f1f-9c1a-8b132c220b3c","excerpt":"Deploying a static Gatsby site to CloudFront can be challenging. There is an excellent\n gatsby-plugin-s3  (which I'll be using) with a…","slug":"/gatsby-deployment-to-cloudfront-using-serverless/","title":"Deploying a Gatsby site to CloudFront using Serverless","date":"February 28, 2021"}},"pageContext":{"id":"fed733e3-160f-56fc-8259-610061f37fdc","previousId":"90047d6c-9f9b-5943-b5ca-cba285ebec0e","nextId":"56b1d61b-c6f9-5f1f-9c1a-8b132c220b3c","maxWidth":1380}},"staticQueryHashes":["2744905544","3090755652","3473179899","764694655","955223363"]}